diff --git a/drivers/gpu/drm/i915/i915_request.c b/drivers/gpu/drm/i915/i915_request.c
index 26a7a57785c7..ae9ce46e1b15 100644
--- a/drivers/gpu/drm/i915/i915_request.c
+++ b/drivers/gpu/drm/i915/i915_request.c
@@ -823,39 +823,6 @@ already_busywaiting(struct i915_request *rq)
 	return rq->sched.semaphores | rq->hw_context->saturated;
 }
 
-static int
-i915_request_await_start(struct i915_request *rq, struct i915_request *signal)
-{
-	if (list_is_first(&signal->ring_link, &signal->ring->request_list))
-		return 0;
-
-	signal = list_prev_entry(signal, ring_link);
-	if (i915_timeline_sync_is_later(rq->timeline, &signal->fence))
-		return 0;
-
-	return i915_sw_fence_await_dma_fence(&rq->submit,
-					     &signal->fence, 0,
-					     I915_FENCE_GFP);
-}
-
-static intel_engine_mask_t
-already_busywaiting(struct i915_request *rq)
-{
-	/*
-	 * Polling a semaphore causes bus traffic, delaying other users of
-	 * both the GPU and CPU. We want to limit the impact on others,
-	 * while taking advantage of early submission to reduce GPU
-	 * latency. Therefore we restrict ourselves to not using more
-	 * than one semaphore from each source, and not using a semaphore
-	 * if we have detected the engine is saturated (i.e. would not be
-	 * submitted early and cause bus traffic reading an already passed
-	 * semaphore).
-	 *
-	 * See the are-we-too-late? check in __i915_request_submit().
-	 */
-	return rq->sched.semaphores | rq->hw_context->saturated;
-}
-
 static int
 emit_semaphore_wait(struct i915_request *to,
 		    struct i915_request *from,
